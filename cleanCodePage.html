<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name = "viewport" content="width=device-width, initial-scale=1.0">

  <link rel="stylesheet" type="text/css" href="style.css">
  <title>Beginner Bootcamp</title>
    <style>
      * {
        box-sizing: border-box;
        }
      body{
            background-image: url("tlo01.jpg");
            background-repeat: no-repeat;
            background-attachment: fixed;
            background-position: relative;
            background-size: 100%;
            left: 0; top: 0;
             margin:0;
            }
   </style>
</head>

 <body>

   <div class = "header">
   <h1>Welcome to our first Web Page</h1>
   </div>


   <div class=menubar>
    <a href="index.html">HOME</a>
    <a href="structurePage.html">HTML/ Structure</a>
    <a href="tagsPage.html">HTML/ Tags & Attributes</a>
    <a href="linksPage.html">HTML/ Links</a>
    <a href="introductionPage.html">CSS/ Introduction</a>
    <a href="colorPage.html">CSS/ Color, Text and Images</a>
    <a href="BoxModelPage.html">CSS/ Box Model</a>
    <a href="PositionPage.html">CSS/ Positioning</a>
    <a href="flexboxPage.html">CSS/ FlexBox</a>
    <a href="cleanCodePage.html">Clean Code/ Refactoring</a>
    <a href="tipsPage.html">Clean Code/ Tips</a>
  </div>
    <div class="content">
      <p>
        <h2>Clean Code/ Refactoring</h2>
        Refactoring is a process of taking existing code and improves it while it makes code more readable, understandable, and clean. Also, it becomes very handy to add new features, build large applications and spot & fix bugs.
        It is a law of nature for fully successful iterative projects. You don’t decide to refactor, you refactor because you want to do something else and refactoring helps you to do that. When you refactor existing code of a project (software/app etc) by altering its internal structure but you are not changing its external behavior.
        Refactoring even take a bad design of a project and rework it into a good one. You are not changing observable behavior of the project you improves the internal structure by Refactoring.
        Refactoring also removes “Code Smells” from your project, this is done to get certain benefits and these benefits may not be consumable immediately but over the long term. It is a activity which is a solution to your problems, its performed when modifying the existing code of a project to incorporate new features or to enhance.

        <h3>Indentation</h3>
        Indentation is starting each nested level piece of code further to the right with code belonging to the same nesting level starting on the same height.  Indentations serve no other purpose than making the code readable to you and others

        <h3>DRY Code</h3>
        In software engineering, don't repeat yourself (DRY) is a principle of software development aimed at reducing repetition of software patterns, replacing them with abstractions; and several copies of the same data, using data normalization to avoid redundancy.
        The DRY principle is stated as "Every piece of knowledge must have a single, unambiguous, authoritative representation within a system". The principle has been formulated by Andy Hunt and Dave Thomas in their book The Pragmatic Programmer. They apply it quite broadly to include "database schemas, test plans, the build system, even documentation".[1] When the DRY principle is applied successfully, a modification of any single element of a system does not require a change in other logically unrelated elements. Additionally, elements that are logically related all change predictably and uniformly, and are thus kept in sync. Besides using methods and subroutines in their code, Thomas and Hunt rely on code generators, automatic build systems, and scripting languages to observe the DRY principle across layers.

        <h3>KISS</h3>
        KISS (Keep It Simple Stupid) means you have to keep it simple. Simple code is less prone to bugs, and is easier to read and understand for you and the people who'll be working on the code in the future (including yourself). And now you're probably thinking you're already doing that. Duh, why would you write complex code? Maybe you even think of yourself as not being a good enough programmer to write complex code! Let me tell you why this is probably not the case.
        Keeping things simple is, ironically, not simple! It requires abstract thinking. It requires knowledge of the domain you're working on. It requires knowledge of the code, the framework, and the language you're working with. It requires experience.

        <br><br><i>QUOTE: Any fool can write code that a computer can understand. Good programmers write code that humans can understand.</i><br>
        <b>—Martin Fowler</b> <br><br>

          <h3>seperation of concerns</h3>
          separation of concerns (SoC) is a design principle for separating a computer program into distinct sections, such that each section addresses a separate concern. A concern is a set of information that affects the code of a computer program. A concern can be as general as the details of the hardware the code is being optimized for, or as specific as the name of a class to instantiate. A program that embodies SoC well is called a modular[1] program. Modularity, and hence separation of concerns, is achieved by encapsulating information inside a section of code that has a well-defined interface. Encapsulation is a means of information hiding.[2] Layered designs in information systems are another embodiment of separation of concerns (e.g., presentation layer, business logic layer, data access layer, persistence layer).[3]
      </p>
    </div>



    <div class="footer">
     <h2> Malgorzata Bram Lennart Ceferino</h2>
    </div>

 </body>
</html>
